Understanding Bash Scripting Basics
===================================
    => `$1 & $2`    -> First & second argument
    => `$@`         -> All arguments
    => `*`          -> All (Ex:- ls *.txt)
    => ``           -> Backticks (`) indicate command substitution. (Ex:- echo `whoami`)
    => \            ->  backslash (\) is the escape character in bash. (Ex:- \", \$, \`, \\ => ", $, `, \)
    => `$()`        -> TODAY=$(date) -> assigns today's date 
    => `$#`         -> Total number of arguments
    => `$?`         -> contains the exit value of the last command executed
    => `$$`         -> which contains the current process’s ID. 
    => `PROGRAM > FILENAME`     -> Writes the program’s output
    => `PROGRAM >> FILENAME`    -> Appends the output
    => `PROGRAM < FILENAME`     -> Reads from the file and uses its content as the program input. 
    => `PROGRAM1 | PROGRAM2`    -> Uses the output of PROGRAM1 as the input to PROGRAM2.
    => `~/.bash_profile`        -> Updates Vars
    => `chmod +x recon.sh` / `chmod 700 recon.sh`   -> Update file permissions
*****************************
    => `-f`                 -> flag tests whether a file exists
    => `-eq`                -> equality
    => `-ne`                -> inequality
    => `-gt`                -> greater than  
    => `-ge`                -> greater than or equal to  
    => `-lt`                -> less than
    => `-le`                -> less than or equal to
    => `-z` and `-n`        -> whether a string is empty
    => The `-d`, `-f`, `-r`, `-w`, and `-x` flags check for directory and file statuses. You can use them to check the 
    existence and permissions of a file before your shell script operates on them.
        => `if [ -d /bin]`          -> `true` if `/bin` is a directory that exists
        => `if [ -f /bin/bash ]`    -> `true` if `/bin/bash` is a file that exists
        => `if [ -r /bin/bash ]`    -> `true` if `/bin/bash` is a readable file
        => `if [ -w /bin/bash ]`    -> `true` if `/bin/bash` is a writable file
        => `if [ -x /bin/bash ]`    -> `true` if `/bin/bash` is a executable file
        => `if [ $3 -gt 1 ] && [ $3 -lt 3 ]`    -> `true` if both expressions are `true`
        => `if [ $3 -gt 1 ] || [ $3 -lt 3 ]`    -> `true` if at least one of them is `true`
*****************************
    => ``curl "URL" -o $DIRECTORY/crt``            -> Downloads the content & stores on -o file
    ```
        #!/bin/sh
        chmod 777 script.sh
        if [ "$?" -ne "0" ]; then
            echo "Chmod failed. You might not have permissions to do that!"
        fi
    ```
*****************************    
    => `$1, $2, $3` only to the values the function is called with, so you can’t use a script’s input args within a function
    => `$DOMAIN, $DIRECTORY, $PATH_TO_DIRSEARCH` available throughout the script after we’ve declared them, even if they’re 
       declared within functions
    ```
        nmap_scan() {
            nmap $1 > $DIRECTORY/nmap
            echo "The results of nmap scan are stored in $DIRECTORY/nmap."
        }
        nmap_scan
    ```
    => $1 in the function refers to the 1st arg that nmap_scan was called with, not the arg our recon.sh script was called with.
    Since nmap_scan wasn’t called with any arguments, $1 is blank.
*****************************
    =>  if [ condition 1 ]; then 
            # Do if condition 1 is satisfied
        elif [ condition 2 ]; then 
            # Do if condition 2 is satisfied, and condition 1 is not satisfied
        else
            # Do something else if neither condition is satisfied
        fi
*****************************
for i in LIST_OF_VALUES; do
    DO SOMETHING
done
*****************************
while CONDITION; do
    DO SOMETHING
done
```
    while [ $INPUT != "quit" ];do
        echo "Please enter a domain!"
        read INPUT
        if [ $INPUT != "quit" ];then
            scan_domain $INPUT
            report_domain $INPUT
        fi
    done
```
*****************************
case $VARIABLE_NAME in
    case1)
        Do something
        ;;
    caseN)
        Do something
        ;;
    *)
        Default case, this case is executed if no other case matches.
        ;;
    esac
*****************************
```
    #!/bin/bash
    echo "Creating directory $1_recon."
    mkdir $1_recon
    nmap $1 > $1_recon/nmap
    echo "The results of nmap scan are stored in $1_recon/nmap."
    /PATH/TO/dirsearch.py -u $1 -e php --simple-report=$1_recon/dirsearch
    echo "The results of dirsearch scan are stored in $1_recon/dirsearch."
    ****************
        => simple-report flag => Generates a report in the designated location.
    ****************
```
```
    #!/bin/bash
    PATH_TO_DIRSEARCH="/Users/vickieli/tools/dirsearch"
    TODAY=$(date)
    echo "This scan was created on $TODAY"
    DIRECTORY=${DOMAIN}_recon
    echo "Creating directory $DIRECTORY."
    mkdir $DIRECTORY
    if [ $2 == "nmap-only" ] 
        then
            nmap $DOMAIN > $DIRECTORY/nmap
            echo "The results of nmap scan are stored in $DIRECTORY/nmap."
    elif [ $2 == "dirsearch-only" ] 
        then
            $PATH_TO_DIRSEARCH/dirsearch.py -u $DOMAIN -e php –simple-report=$DIRECTORY/dirsearch
            echo "The results of dirsearch scan are stored in $DIRECTORY/dirsearch."
    else
    nmap $DOMAIN > $DIRECTORY/nmap 
    echo "The results of nmap scan are stored in $DIRECTORY/nmap."
    $PATH_TO_DIRSEARCH/dirsearch.py -u $DOMAIN -e php --simple-report=$DIRECTORY/dirsearch
    echo "The results of dirsearch scan are stored in $DIRECTORY/dirsearch."
    fi
```
```
    #!/bin/bash
    PATH_TO_DIRSEARCH="/Users/vickieli/tools/dirsearch"
    DOMAIN=$1
    DIRECTORY=${DOMAIN}_recon
    echo "Creating directory $DIRECTORY."
    mkdir $DIRECTORY
    nmap_scan() {
        nmap $DOMAIN > $DIRECTORY/nmap
        echo "The results of nmap scan are stored in $DIRECTORY/nmap."
    }
    dirsearch_scan() {
        $PATH_TO_DIRSEARCH/dirsearch.py -u $DOMAIN -e php --simple-report=$DIRECTORY/dirsearch
        echo "The results of dirsearch scan are stored in $DIRECTORY/dirsearch."
    }
    crt_scan() {
        curl "https://crt.sh/?q=$DOMAIN&output=json" -o $DIRECTORY/crt
        echo "The results of cert parsing is stored in $DIRECTORY/crt."
    }

    case $2 in
        nmap-only)
            nmap_scan
            ;;
        dirsearch-only)
            dirsearch_scan
            ;;
        crt-only)
            crt_scan
            ;;
        *)
            nmap_scan
            dirsearch_scan
            crt_scan
            ;;
    esac

    echo "Generating recon report from output files..."
    TODAY=$(date)
    echo "This scan was created on $TODAY" > $DIRECTORY/report
    echo "Results for Nmap:" >> $DIRECTORY/report
    grep -E "^\s*\S+\s+\S+\s+\S+\s*$" $DIRECTORY/nmap >> $DIRECTORY/report
    echo "Results for Dirsearch:" >> $DIRECTORY/report
    cat $DIRECTORY/dirsearch >> $DIRECTORY/report
    echo "Results for crt.sh:" >> $DIRECTORY/report
    jq -r ".[] | .name_value" $DIRECTORY/crt >> $DIRECTORY/report
```
```
#!/bin/bash
PATH_TO_DIRSEARCH="/Users/vickieli/tools/dirsearch"
nmap_scan() {
    nmap $DOMAIN > $DIRECTORY/nmap
    echo "The results of nmap scan are stored in $DIRECTORY/nmap."
}
dirsearch_scan() {
    $PATH_TO_DIRSEARCH/dirsearch.py -u $DOMAIN -e php --simple-report=$DIRECTORY/dirsearch
    echo "The results of dirsearch scan are stored in $DIRECTORY/dirsearch."
}
crt_scan() {
    curl "https://crt.sh/?q=$DOMAIN&output=json" -o $DIRECTORY/crt
    echo "The results of cert parsing is stored in $DIRECTORY/crt."
}
getopts "m:" OPTION
MODE=$OPTARG
for i in "${@:$OPTIND:$#}" 1
do
    DOMAIN=$i
    DIRECTORY=${DOMAIN}_recon
    echo "Creating directory $DIRECTORY."
    mkdir $DIRECTORY

     case $MODE in
        nmap-only)
            nmap_scan
            ;;
        dirsearch-only)
            dirsearch_scan
            ;;
        crt-only)
            crt_scan
            ;;
        *)
            nmap_scan
            dirsearch_scan
            crt_scan
            ;;
        esac
        echo "Generating recon report for $DOMAIN..."
        TODAY=$(date)
        echo "This scan was created on $TODAY" > $DIRECTORY/report
        if [ -f $DIRECTORY/nmap ];then
            echo "Results for Nmap:" >> $DIRECTORY/report
            grep -E "^\s*\S+\s+\S+\s+\S+\s*$" $DIRECTORY/nmap >> $DIRECTORY/report
        fi
        if [ -f $DIRECTORY/dirsearch ];then
            echo "Results for Dirsearch:" >> $DIRECTORY/report
            cat $DIRECTORY/dirsearch >> $DIRECTORY/report
        fi
        if [ -f $DIRECTORY/crt ];then
            echo "Results for crt.sh:" >> $DIRECTORY/report
            jq -r ".[] | .name_value" $DIRECTORY/crt >> $DIRECTORY/report
        fi
        done
```
**********************************************************************************************************
**********************************************************************************************************
**********************************************************************************************************
===================================
regex
=====
    => RexEgg’s cheat sheet (https://www.rexegg.com/regex-quickstart.html).
        [\d]    => Any digit
        [\w]    => Any character
        [\s]    => Any whitespace 
        [\S]    => Any non-whitespace
        [.]     => Any single character
        [\]     => Escapes a special character
        [^]     => start of the string or line.
        [$]     => end of the string or line.
    => Several operators also specify the number of characters to match:
        [*]         => Zero or more times
        [+]         => One or more times
        [{3}]       => Three times
        [{1, 3}]    => One to three times
        [{1, }]     => One or more times
        [[abc]]     => One of the characters within the brackets
        [[a-z]]     => One of the characters within the range of a to z
        [(a|b|c)]   => Either a or b or c
        [^\S+\s+\S+\s+\S+$] => Three strings separated by two whitespaces

    [grep password file.txt]            -> Search for the string "password" in the file "file.txt"
    [grep 80 TARGET_DIRECTORY/nmap]     -> Search for the string "80" in the file "TARGET_DIRECTORY/nmap"
    [grep -E "^\S+\s+\S+\s+\S+$" DIRECTORY/nmap > DIRECTORY/nmap_cleaned] (-E for regex)

**********************************************************************************************************
**********************************************************************************************************
**********************************************************************************************************
***************************************************
jp - Command line utility that processes JSON.
====
    [Docs]  =>  https://stedolan.github.io/jq/manual/
    [jq -r ".[] | .name_value" $DOMAIN/crt]     
        =>  Extracts the "name_value" field of each certificate item to extract domain names
        => -r flag tells jq to write the output directly to standard output rather than format it as JSON strings
        => .[]  iterates through the array within the JSON file
        => .name_value extracts the name_value field of each item
        => $DOMAIN/crt is the input file to the jq command

***************************************************
getopts
=======
    => The getopts tool parses options from the command line by using single-character flags. -m flag to specify the scan 
    mode and assume that all other arguments are domains. The getopts tool also automatically stores the value of any options 
    into the $OPTARG variable. We can store that value into a variable named "MODE":
        => ```
            getopts "m:" OPTION
            MODE=$OPTARG
        ```
        => Now if you run the shell script with an -m flag, the script will know that you’re specifying a scan MODE! Note 
        that getopts stops parsing arguments when it encounters an argument that doesn’t start with the - character, so you’ll 
        need to place the scan mode before the domain arguments when you run the script:
        ```./recon.sh -m nmap-only facebook.com fbcdn.net```
    => [-m and -i] you should specify mi, If you want an option  to contain argument values, the letter should be followed 
    by a colon, like this: m:i.
    [getopts OPTSTRING NAME]    => "NAME" specifies the variable name that stores the option letter
    ```
    for i in "${@:$OPTIND:$#}"
    do
        # Do the scans for $i
    done
        => `$@` represent the array containing all input arguments
        => `$#` is the number of command line arguments passed in
        => `"${@:OPTIND:}"` slices the array so that it removes the MODE argument, like nmap-only, making sure that we iterate 
        through only the domains part of our input. Array slicing is a way of extracting a subset of items from an array. In bash, 
        you can slice arrays by using this syntax (note that the quotes around the command are necessary)
        `"${INPUT_ARRAY:START_INDEX:END_INDEX}"`
    ```


    => In Unix, commands return 0 on success and a positive integer on failure. The variable $? contains the exit value of the 
    last command executed. You can use these to test for execution successes and failures:



