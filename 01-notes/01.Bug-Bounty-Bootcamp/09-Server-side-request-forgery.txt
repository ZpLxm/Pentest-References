Server-side Request Forgery (SSRF) 
==================================

Mechanisms
==========
    => SSRF vulnerabilities occur when an attacker finds a way to send requests as a trusted server in the target’s network. 
    Imagine a public-facing web server on example.com’s network named public.example.com. This server hosts a proxy service, 
    located at public.example.com/proxy, that fetches the web page specified in the url parameter and displays it back to the user. 
    For example, when the user accesses the following URL, the web application would display the google.com home page:
    => ```
        https://public.example.com/proxy?url=https://google.com
    ```
    => Now let’s say admin.example.com is an internal server on the network hosting an admin panel. To ensure that only employees 
    can access the panel, administrators set up access controls to keep it from being reached via the internet. Only machines 
    with a valid internal IP, like an employee workstation, can access the panel. Now, what if a regular user accesses the 
    following URL?
    => ```
        https://public.example.com/proxy?url=https://admin.example.com
    ```
    => Here, the url parameter is set to the URL of the internal admin panel. With no SSRF protection mechanism in place, the 
    web application would display the admin panel to the user, because the request to the admin panel is coming from the web server, 
    public.example.com, a trusted machine on the network.

    => Through SSRF, servers accept unauthorized requests that firewall controls would normally block, like fetching the admin 
    panel from a non-company machine. Often, the protection that exists on the network perimeter, between public-facing web servers 
    and internet machines, does not exist between machines on the trusted network. Therefore, the protection that hides the 
    admin panel from the internet doesn’t apply to requests sent between the web server and the admin panel server.
    
    => By forging requests from trusted servers, an attacker can pivot into an organization’s internal network and conduct all 
    kinds of malicious activities. Depending on the permissions given to the vulnerable internet-facing server, an attacker might 
    be able to read sensitive files, make internal API calls, and access internal services.
    
    => SSRF vulnerabilities have two types: regular SSRF and blind SSRF. The mechanisms behind both are the same: each exploits the 
    trust between machines on the same network. The only difference is that in a blind SSRF, the attacker does not receive feedback 
    from the server via an HTTP response or an error message. For instance, in the earlier example, we’d know the SSRF worked if we 
    see admin.example.com displayed. But in a blind SSRF, the forged request executes without any confirmation sent to the attacker

    => Let’s say that on public.example.com another functionality allows users to send requests via its web server. But this endpoint 
    does not return the resulting page to the user. If attackers can send requests to the internal network, the endpoint suffers 
    from a blind SSRF vulnerability:
    => ```
        https://public.example.com/send_request?url=https://admin.example.com/delete_user?user=1
    ```
    => Although blind SSRFs are harder to exploit, they’re still extremely valuable to an attacker, who might be able to perform 
    network scanning and exploit other vulnerabilities on the network. We’ll get more into this later

Prevention
==========
    => SSRFs happen when servers need to send requests to obtain external resources. For example, when you post a link on Twitter, 
    Twitter fetches an image from that external site to create a thumbnail. If the server doesn’t stop users from accessing internal 
    resources using the same mechanisms, SSRF vulnerabilities occur. Let’s look at another example. Say a page on public.example.com 
    allows users to upload a profile photo by retrieving it from a URL via this POST request:
    => ```
        POST /upload_profile_from_url
        Host: public.example.com

        (POST request body)
        user_id=1234&url=https://www.attacker.com/profile.jpeg    
    ```
    => To fetch profile.jpeg from attacker.com, the web application would have to visit and retrieve contents from attacker.com. 
    This is the safe and intended behavior of the application. But if the server does not make a distinction between internal and 
    external resources, an attacker could just as easily request a local file stored on the server, or any other file on the network. 
    For instance, they could make the following POST request, which would cause the web server to fetch the sensitive file and 
    display it as the user’s profile picture:
    => ```
        POST /upload_profile_from_url
        Host: public.example.com

        (POST request body)
        user_id=1234&url=https://localhost/passwords.txt
    ```
    => Two main types of protection against SSRFs exist: blocklists and allowlists. Blocklists are lists of banned addresses. 
    The server will block a request if it contains a blocklisted address as input. Because applications often need to fetch resources 
    from a variety of internet sources, too many to explicitly allow, most applications use this method. Companies blocklist internal 
    network addresses and reject any request that redirects to those addresses.

    => On the other hand, when a site implements allowlist protection, the server allows only requests that contain URLs found in a 
    predetermined list and rejects all other requests. Some servers also protect against SSRFs by requiring special headers or 
    secret tokens in internal requests.

Hunting for SSRFs
=================
    => The best way to discover SSRF vulnerabilities is through a review of the application’s source code, in which you check 
    if the application validates all user-provided URLs. But when you can’t obtain the source code, you should focus your efforts 
    on testing the features most prone to SSRF.
    
    Step 1: Spot Features Prone to SSRFs
    ====================================
    => SSRFs occur in features that require visiting and fetching external resources. These include webhooks, file uploads, 
    document and image processors, link expansions or thumbnails, and proxy services. It’s also worth testing any endpoint that 
    processes a user-provided URL. And pay attention to potential SSRF entry points that are less obvious, like URLs embedded in 
    files that are processed by the application (XML files and PDF files can often be used to trigger SSRFs), hidden API endpoints 
    that accept URLs as input, and input that gets inserted into HTML tags.
    
    => Webhooks are custom HTTP callback endpoints used as a notification system for certain application events. When an event 
    such as new user sign-up or application error occurs, the originating site will make an HTTP request to the webhook URL. 
    These HTTP requests help the company collect information about the website’s performance and visitors. It also helps 
    organizations keep data in sync across multiple web applications.

    => And in the event that one action from an application needs to trigger an action on another application, webhooks are a 
    way of notifying the system to kick-start another process. For example, if a company wants to send a welcome email to every 
    user who follows its social media account, it can use a webhook to connect the two applications.
    
    => Many websites allow users to set up their webhook URLs, and these settings pages are often vulnerable to SSRF. Most of the time, 
    an application’s webhook service is in its developers’ portal. For example, Slack allows application owners to set up a webhook 
    via its app configuration page (https://api.slack.com/apps/). Under the Event Subscriptions heading, you can specify a URL at 
    which Slack will notify you when special events happen (Figure 13-1). The Request URL field of these webhook services is often 
    vulnerable to SSRF.
    
    => On the other hand, proxy services refer to services that act as an intermediary between two machines. They sit between the 
    client and the server of a request to facilitate or control their communication. Common use cases of proxy services are to bypass 
    organization firewalls that block certain websites, browse the internet anonymously, or encrypt internet messages.

    => Notice these potentially vulnerable features on the target site and record them for future reference in a list like this:
    
    Potential SSRF Endpoints
    ========================
    => ```Add a new webhook:```
        POST /webhook
        Host: public.example.com

        (POST request body)
        url=https://www.attacker.com
    ```
    => ```File upload via URL:```
        POST /upload_profile_from_url
        Host: public.example.com

        (POST request body)
        user_id=1234&url=https://www.attacker.com/profile.jpeg
    ```
    => ```Proxy service:```
        https://public.example.com/proxy?url=https://google.com
    ```

    Step 2: Provide Potentially Vulnerable Endpoints with Internal URLs
    ===================================================================
    => Once you’ve identified the potentially vulnerable endpoints, provide internal addresses as the URL inputs to these endpoints. 
    Depending on the network configuration, you might need to try several addresses before you find the ones in use by the network. 
    Here are some common ones reserved for the private network: 
        => ```
            localhost, 
            127.0.0.1, 
            0.0.0.0, 
            192.168.0.1, 
            and 10.0.0.1.
        ```
        ```
            You can find more reserved IP addresses used to identify machines on the private network at
            https://en.wikipedia.org/wiki/Reserved_IP_addresses. 
        ```
    => To illustrate, this request tests the webhook functionality:
    => ```
        POST /webhook
        Host: public.example.com

        (POST request body)
        url=https://192.168.0.1
    ```
    => This request tests the file upload functionality:
    => ```
        POST /upload_profile_from_url
        Host: public.example.com

        (POST request body)
        user_id=1234&url=https://192.168.0.1
    ```
    => And this request tests the proxy service:
    => ```
            https://public.example.com/proxy?url=https://192.168.0.1
    ```

    Step 3: Check the Results
    =========================
    => In the case of regular SSRF, see if the server returns a response that reveals any information about the internal service. 
    For example, does the response contain service banners or the content of internal pages? A service banner is the name and 
    version of the software running on the machine. Check for this by sending a request like this:
    => ```
        POST /upload_profile_from_url
        Host: public.example.com
        (POST request body)
        user_id=1234&url=127.0.0.1:22
    ```
    => Port 22 is the default port for the Secure Shell Protocol (SSH). This request tells the application that the URL of our 
    profile picture is located at 127.0.0.1:22, or port 22 of the current machine. This way, we can trick the server into visiting 
    its own port 22 and returning information about itself. Then look for text like this in the response:
    => ```
        Error: cannot upload image: SSH-2.0-OpenSSH_7.2p2 Ubuntu-4ubuntu2.4
    ```
    => If you find a message like this, you can be sure that an SSRF vulnerability exists on this endpoint, since you were 
    able to gather information about the localhost.
    
    => The easiest way of detecting blind SSRFs is through out-of-band techniques: you make the target send requests to an 
    external server that you control, and then monitor your server logs for requests from the target. One way to do this is 
    to use an online hosting service, such as GoDaddy or Hostinger, that provides server access logs. You can link your hosted 
    site to a custom domain and submit that domain in the SSRF testing payload.
    
    => You can also turn your own machine into a listener by using Netcat, a utility installed by default on most Linux machines. 
    If you don’t already have Netcat, you can install it by using the command apt-get install netcat. Then use nc -lp 8080 to 
    start a listener on port 8080. After this, you can point your SSRF payloads to your IP address on port 8080 and monitor for any
    incoming traffic. Another easier way of doing this is to use the Collaborator feature in Burp Suite Pro, which automatically 
    generates unique domain names, sends them as payloads to the target, and monitors for any interaction associated with the target.

    => However, being able to generate an outbound request from the target server alone is not an exploitable issue. Since you 
    cannot use blind SSRFs to read internal files or access internal services, you need to confirm their exploitability by trying 
    to explore the internal network with the SSRF. Make requests to various target ports and see if server behavior differs between 
    commonly open and closed ports. For example, ports 22, 80, and 443 are commonly open ports, while port 11 is not. This will help 
    you determine if an attacker can use the SSRF to access the internal network. You can look especially for differences in response 
    time and HTTP response codes.
    => For example, servers use the HTTP status code 200 to indicate that a request has succeeded. Often, if a server is able to 
    connect to the specified port, it will return a 200 status code. Say the following request results in an HTTP status code of 200:
    => ```
        POST /webhook
        Host: public.example.com

        (POST request body)
        url=https://127.0.0.1:80
    ```
    => The following request instead results in an HTTP status code of 500, the status code for Internal Server Error. Servers 
    return 500 status codes when they run into an error while processing the request, so a 500 status code often indicates a 
    closed or protected port:
    => ```
        POST /webhook
        Host: public.example.com

        (POST request body)
        url=https://127.0.0.1:11
    ```
    => You can confirm that the server is indeed making requests to these ports and responding differently based on port status. 
    Also look for the time difference between responses. You can see in that the Burp repeater shows how long it took for the 
    server to respond in the bottom right corner. Here, it took 181 milliseconds for Google to return its home page. You can 
    use tools like SSRFmap to automate this process.
    => ```
        SSRFmap     - https://github.com/swisskyrepo/SSRFmap
    ```
    => If a port is closed, the server usually responds faster because it drops the forwarded traffic immediately, whereas 
    internal firewalls often cause a delay in the response. Attackers can use time delays as a metric to figure out a target’s 
    internal network structure. If you can identify a significant time difference between requests to different ports, you have 
    found an exploitable SSRF.

Bypassing SSRF Protection
=========================
    => What if you submit an SSRF payload, but the server returns this response?
    => ```
        Error. Requests to this address are not allowed. Please try again.
    ```
    => This SSRF was blocked by a protection mechanism, possibly a URL allowlist or blocklist. But all is not lost! The site 
    may have protection mechanisms implemented, but this doesn’t mean that the protection is complete. Here are a few more things 
    you can try to bypass a site’s protection.

    Bypass Allowlists
    =================
    => Allowlists are generally the hardest to bypass, because they are, by default, stricter than blocklists. But getting around 
    them is still possible if you can find an open redirect vulnerability within the allowlisted domains. If you find one, you can 
    request an allowlisted URL that redirects to an internal URL. For example, even if the site allows only profile pictures 
    uploaded from one of its subdomains, you can induce an SSRF through an open redirect.

    => In the following request, we utilize an open redirect on pics.example.com to redirect the request to 127.0.0.1, the IP address 
    for the localhost. This way, even though the url parameter passes the allowlist, it still redirects to a restricted internal address:
    => ```
        POST /upload_profile_from_url
        Host: public.example.com

        (POST request body)
        user_id=1234&url=https://pics.example.com/123?redirect=127.0.0.1
    ```
    => The server could also have implemented its allowlist via poorly designed regular expressions (regexes). Regexes are often 
    used to construct more flexible allowlists. For example, instead of checking whether a URL string is equal to "example.com", 
    a site can check regex expressions like .*example.com.* to match the subdomains and filepaths of example.com as well. In those 
    cases, you could bypass the regex by placing the allowlisted domain in the request URL. For example, this request will redirect 
    to 127.0.0.1, since pics.example.com is seen as the username portion of the URL:
    => ```
        POST /upload_profile_from_url
        Host: public.example.com

        (POST request body)
        user_id=1234&url=https://pics.example.com@127.0.0.1
    ```
    => The following request also redirects to 127.0.0.1, since pics.example.com is seen as the directory portion of the URL:
    => ```
        POST /upload_profile_from_url
        Host: public.example.com

        (POST request body)
        user_id=1234&url=https://127.0.0.1/pics.example.com
    ```
    => You can test whether a site is using an overly flexible regex allowlist by trying URLs like these and seeing if the filter 
    allows it. Note that a regex-based allowlist can be secure if the regex is well constructed. And these URLs won’t always succeed!

    Bypass Blocklists
    =================
    => Since applications often need to fetch resources from a variety of internet sources, most SSRF protection mechanisms 
    come in the form of a blocklist. If you’re faced with a blocklist, there are many ways of tricking the server. 

        Fooling It with Redirects
        =========================
        => First, you can make the server request a URL that you control and that redirects to the blocklisted address. 
        For example, you can ask the target server to send a request to your server:
        => ```
            https://public.example.com/proxy?url=https://attacker.com/ssrf
        ```
        => Then, on your server at https://attacker.com/ssrf, you can host a file with the following content:
        => ```
            <?php header("location: http://127.0.0.1"); ?>
        ```
        => This is a piece of PHP code that redirects the request by setting the document’s location to 127.0.0.1. When you make 
        the target server request https://attacker.com/ssrf, the target server is redirected to http://127.0.0.1, a restricted 
        internal address. This attack will bypass blocklists because the URL submitted to the application does not itself contain 
        any blocklisted addresses.

        Using IPv6 Addresses
        ====================
        => I mentioned in Chapter 3 that IPv6 addresses are a newer alternative to the more commonly used IPv4 addresses. The 
        Internet Engineering Task Force (IETF) created IPv6 addresses as the world began running out of available IPv4 addresses 
        and needed a format that provided a larger number of possible addresses. IPv6 addresses are 128-bit values represented in 
        hexadecimal notation, and they look like this: 64:ff9b::255.255.255.255.
        
        => Sometimes the SSRF protection mechanisms a site has implemented for IPv4 might not have been implemented for IPv6. 
        That means you can try to submit IPv6 addresses that point to the local network. For example, the IPv6 address ::1 points 
        to the localhost, and fc00:: is the first address on the private network.
        => ```
            For more information about how IPv6 works, and about other reserved
            IPv6 addresses, visit Wikipedia: https://en.wikipedia.org/wiki/IPv6_address.
        ```
        Tricking the Server with DNS
        ============================
        => 


